## メソッドのセマンティクス

メソッドの宣言の仕方が分かったので、セマンティクスを見ていきましょう。
置き換えモデルを使った場合、メソッド呼び出しはどう理解すればいいでしょう?

メソッド呼び出しはそれが評価する値へと置き換えることができると分かっています。
しかし、この値を導き出すためにはもう少しきめ細かいモデルを必要とします。
モデルを以下のように拡張します: メソッド呼び出しを見ると、新しいブロックを作り、そのブロック内ではパラメータをそれぞれに対応するメソッド呼び出し引数へと束縛してメソッド本体を置き換えます。

これで普通どおり置き換えを適用できるようになりました。

簡単な例を見てみましょう。以下のメソッドがあるとき

```tut:silent:book
def square(x: Int): Int =
  x * x
```

このメソッド呼び出しは

```tut:silent:book
square(2)
```

ブロックを導入して

```tut:silent:book
{
  square(2)
}
```

パラメータ `x` を `2` に束縛して、

```tut:silent:book
{
  val x = 2
  square(2)
}
```

メソッド本文を置き換えることで展開することができます。

```tut:silent:book
{
  val x = 2
  x * x
}
```

これで通常の置き換えを行い、以下を得ることができます。

```tut:silent:book
{
  2 * 2
}
```

そしてこうなります。

```tut:silent:book
{
  4
}
```

前にも見ましたが、置き換えは複雑ですが、各ステップの一つ一つは特に難しいものではないことが分かります。

### 練習問題 {-}

前回置き換えを見たときは評価の順序に多くの時間をさきました。
上の説明でメソッドの引数が本文よりも先に評価されることを決めました。
他にも可能な選択肢があります。
例えば、メソッドの引数が必要になった時点で評価することも可能です。
もしメソッドがパラメータの 1つを使わなかった場合は無駄を省くことができるかもしれません。
古い友だちである `println` を使って、Scala においてメソッドのパラメータがいつ評価されているかを調査してみましょう。

<div class="solution">
以下のプログラムはパラメータがメソッドの本文よりも先に評価されることを証明します。

```tut:book
def example(a: Int, b: Int): Int = {
  println("In the method body!")
  a + b
}

example({ println("a"); 1 }, { println("b"); 2 })
```

前述のもう一つの代替方法を採用しているプログラミング言語もあって、その代表として Haskell があり、これは遅延 (lazy) もしくは非正格 (non-strict) 評価と呼ばれます。
</div>
