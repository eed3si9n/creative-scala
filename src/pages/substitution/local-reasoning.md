## 局所推論

副作用があるときには評価順序が大切であることを見てきました。
例えば以下のような副作用のある式があるとき、

```scala
disableWarheads() // 弾頭を無効化
launchTheMissles() // ミサイル発射
```

式が確かに上から下へと評価されて、ミサイルを発射する前に弾頭が無効化されていることを保証したいと思います。

作用はプログラムが世界に対して変化をもたらすことなので、全ての役に立つプログラムは何らかの作用を持ちます。
その作用はプログラムが終了した後に何らかの表示を行うことだけかもしれませんが、作用であることには違いありません。
副作用を最小限にするのは関数型プログラミングにおける重要なゴールの 1つなので、もう少しこの事に関してみてみましょう。

置き換えは非常に分かりやすいものです。
評価の順序が関係無ければ、今見ているコードの意味を他のコードが勝手に変えることが無いことを意味します。
`1 + 1` は、他にどんなコードがプログラムに含まれていようとも `2` ですが、`launchTheMissles()` の作用は弾頭を既に無効化したかしないかに依存します。

結果として、純粋なコードは単独でも理解できることを意味します。
他のコードが意味を変えることが無いので、コードの一部だけを取り出して残りは無視することができます。
一方、非純粋なコードの意味はそれまで評価された全てのコードに依存します。
この特性は**局所推論** (local reasoning) と呼ばれます。
純粋なコードはこの特性を持ち、非純粋なコードはそれを持ちません。

プログラムが大きくなるにつれて全ての詳細を頭の中に入れておくのがどんどん辛くなっていきます。
私たちの頭の大きさは固定されている量なので、唯一の解法は抽象化を導入することです。
抽象化が無関係な詳細を取り除くということを覚えているでしょうか。
純粋なコードは残りのコードの全てが無関係な詳細であると言っているので究極の抽象化であると言えるでしょう。
この大きなプログラムを分かりやすくさせるという能力は、関数型プログラマーをワクワクさせる特性の 1つです。
関数型プログラムは作用を避けるという意味ではありません。全ての有用なプログラムは作用を持ちます。
関数型プログラムが目指すのは、作用をうまく制御することでコードの大部分をシンプルな置き換えモデルを使って推論できるようにすることです。

### 意味の意味

ここまでコードの意味について考察するとき、「意味」をコードが評価される結果もしくはそれが実行する副作用という意味で使ってきました。

置き換えでは、プログラムの意味はそれが評価されたものと全く同じです。
そのため、同じ結果に評価される 2つのプログラムは等価です。
これは、副作用が置き換えを壊す理由です。置き換えモデルは副作用という考えを持たないので、作用に違いのある 2つのプログラムを見分けることができません。

プログラムは評価される結果以外でも異なることがあります。
例えば、同じ結果にたどり着くのに 1つのプログラムは別のものよりも長く時間がかかるかもしれません。
置き換えモデルはこれも区別しません。

置き換えは抽象化であり、値以外の全てのものを捨ててしまいます。
副作用、時間、メモリ使用量などは置き換えにとっては無関係なものですが、プログラムを書いたり実行したりする人にとってはそうではないかもしれません。
ここにトレードオフがあります。
より豊かなモデルを使ってこれらの詳細を捕捉することもできますが、取り扱いは難しくなります。
多くの人にとって多くの場合は、置き換えが非常にシンプルかつ役に立つものなので正しいトレードオフとなります。
