## 評価順序

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

評価順序の話をする準備が整いました。
評価順なんて関係あるのかと思うかもしれません。
これまで見た例だと、式をサブ式の前に評価してはいけないという問題以外では評価順は関係無いように見えます。

これらの問題の考察を行うには新しい概念を導入する必要があります。
ここまではほぼ全て**純粋**な式のみを取り扱ってきました。
これらは自由な順序で置き換えしても問題の無い式のことです[^corner-cases]。

**非純粋**な式は評価順に影響を受けるものです。
これまでに 1つ非純粋な式を見ていて、それは `draw` メソッドです。

```scala
Image.circle(100).draw
Image.rectangle(100, 50).draw
```

と

```scala
Image.rectangle(100, 50).draw
Image.circle(100).draw
```

を評価したとき、イメージを含むウィンドウが異なる順番で現れます。
特に面白みの無い違いですが、確かに違いではあります。

非純粋な式の特徴はそれらの評価が私たちに見える形の変化を引き起こすことです。
例えば、`draw` を評価するとイメージが表示されます。
これらの観測可能な変化を**副作用**もしくは**作用**と呼びます。
副作用を含むプログラムは、自由に置き換えを行うことができません。
しかし、副作用を使って評価順序を調査することができます。
それを行う道具は `println` メソッドです。

`println` メソッドはテキストを console に表示して (副作用)、Unit値に評価されます。
以下が具体例です:

```tut:book
println("Hello!")
```

`println` の console に表示するという副作用は評価順序を調べるのに便利なものです。
例えば、

```tut:book
println("A")
println("B")
println("C")
```

を実行した結果は式が上から下へと評価することを示します。
`println` を使ってさらに調査してみましょう。

### 練習問題 {-}

#### println は置き換えができない {-}

純粋なプログラムはどの式でも名前を与えてその式が出てきた所を名前で置き換えることができます。
具体例で示すと、

```tut:silent:book
(2 + 2) + (2 + 2)
```

を置き換えて、以下のように書くことができ、

```tut:silent:book
val a = (2 + 2)
a + a
```

プログラムの結果は変わりません。

非純粋な式の 1例として `println` を使って、この置き換えが**うまくいかない**こと、そのため副作用とも言われる非純粋な式が置き換えを壊すことを示してみよう。

<div class="solution">
以下はこれを示すシンプルな例です。
以下の 2つのプログラムが異なることを観測することができます。

```tut:book
println("Happy birthday to you!")
println("Happy birthday to you!")
println("Happy birthday to you!")
```

```tut:book
val a = println("Happy birthday to you!")
a
a
a
```

つまり、副作用があるときは自由に置き換えを使うことができないため、評価順序を気にする必要があると言えます。
</div>


#### 狂気のメソッド {-}

スコープを紹介したときにブロック式も見ましたが、そのときはその名前では呼びませんでした。
ブロックは中括弧 (`{}`) を使って作ることができます。それは中括弧内全ての式を評価します。ブロック内の最後の式の結果がブロック式の結果となります。

```tut:book
// 3 に評価される
{
  val one = 1
  val two = 2
  one + two
}
```

ブロック式を使って、何か役に立つ値に評価されるブロックの中に `println` を入れることで、メソッドのパラメータの評価順を調査することができます。

例えば、`Image.rectangle` や `Color.hsl` とブロック式を使って Scala がメソッドパラメータを特定の順序で評価しているのか、そうだとしたらどの順序なのかを調べてみましょう。

セミコロン (`;`) で分けて書くことでブロックをよりコンパクトに 1行で書くことができることに注意してください。
これは普通はお行儀の良い方法ではありませんが、このような実験には役立つかもしれません。
以下が例となります。

```tut:book
// Evaluates to three
{ val one = 1; val two = 2; one + two }
```

<div class="solution">
以下のコードは、メソッドのパラメータが左から右へと評価されていることを示します。

```tut:book
Color.hsl(
  {
    println("a")
    0.degrees
  },
  {
    println("b")
    1.normalized
  },
  {
    println("c")
    1.normalized
  }
)
```

これをよりコンパクトに書くとこうなります

```tut:book
Color.hsl({ println("a"); 0.degrees },
          { println("b"); 1.normalized },
          { println("c"); 1.normalized })
```
</div>


#### ラストオーダー {-}

Scala はどのような順序で式の評価を行っているでしょうか?
満足がいくまで必要な実験を行って答を探してみましょう。
Scala は、全ての式において一貫性のあるルールを適用していると仮定することができます。
異なる式に対する特別な場合はありません。

<div class="solution">
式は上から下へ評価され、メソッドのパラメータは左から右へと評価されることは既に見ました。
一般的な式が左から右へと評価されることをチェックしてみましょう。
これは以下のように比較的簡単に証明できます。

```tut:book
{ println("a"); 1 } + { println("b"); 2 } + { println("c"); 3}
```

結果として、Scala の式は、上から下へ、左から右へと評価されていることが分かりました。
</div>

[^corner-cases]: これは完全には正しくありません。純粋な式においても評価の順序が影響を与えるコーナーケースがいくつかあります。ここではあまりその心配はしなくても大丈夫です。もし興味があるならば、面白いことなので「正格評価」と「遅延評価」に関して調べてみましょう。
