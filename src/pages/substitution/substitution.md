## 置き換え

置き換えは、式を見たら、それが評価される値で置き換えることができるというものです。具体例で説明すると、

```tut:silent:book
1 + 1
```

を見たら、これは `2` で置き換えることができます。
そのため、

This in turn means when we see a compound expression such as

```tut:silent:book
(1 + 1) + (1 + 1)
```

のような複合式が出てきたら `1 + 1` を `2` に置き換えて

```tut:silent:book
2 + 2
```

となり、それは `4` に評価されます。

これは、高校の数学で式を簡易化するときに行ったのと同様の論理的思考です。
当然計算機科学ではこの過程を指す気取った用語があります。
置き換えの他に、これを**式を簡約する**と言ったり、**等式推論** (equational reasoning) と言ったりします。

置き換えは私たちのプログラムを筋道立てて考える方法を与えてくれます。別の言い方とすると、「何が起こっているのかを正確に知ることができる」ということです。
今まで見てきた全ての式に置き換えを適用することができます。
ここではイメージよりも数や文字列を使った例題の方が分かりやすいので、前の章で見た例題に戻ります:

```tut:silent:book
1 + ("Moonage daydream".indexOf("N"))
```

前の例は少し大ざっぱでしたが、ここではもう少し正確にコンピューターが何を行っているかのステップを解説しましょう。
コンピューターを真似ていると思ってください。

`+` を含む式は 2つのサブ式である `1` と `("Moonage daydream".indexOf("N"))` から構成されます。
まず左か、右かのどちらを先に評価するかを決める必要があります。
ここでは、適当に右のサブ式を選ぶことにします (この選択に関してはまた後ほど)。

サブ式である `("Moonage daydream".indexOf("N"))` もまた 2つのサブ式 `"Moonage daydream"` と `"N"` から構成されます。
リテラル式自身は値では無いのでこれらも評価する必要があることを思い出して、再び右側から評価するとします。

リテラルである `"N"` は、値の `"N"` へ評価されます。
混乱を避けるために、この説明文中だけの約束事として、値の方は `|"N"|` と書くことにしましょう。（この `||` を含む式をコピー＆ペーストしても、コンパイルできませんので注意してください。）
これで、最初のステップにより 1つの式をその値に置き換えることができます。

```scala
1 + ("Moonage daydream".indexOf(|"N"|))
```

次に、サブ式の左辺側を評価して、リテラル式 `"Moonage daydream"` をその値である `|"Moonage daydream"|` に置き換えることができます。
これで以下のようになります:

```scala
1 + (|"Moonage daydream"|.indexOf(|"N"|))
```

これで `(|"Moonage daydream"|.indexOf(|"N"|))` という式全体を評価できるようになり、これは `|-1|` に評価されます (ここでも縦棒を使って整数値とリテラル式を区別しています)。
再び置き換えを使って以下を得ます:

```scala
1 + |-1|
```

次に左辺のリテラル `1` を評価して `|1|` を得ます。
置き換えを行って、以下を得ます:

```scala
|1| + |-1|
```

これで式全体を評価できるようになり、以下を得ます:

```scala
|0|
```

Scala に式全体を評価してもらって検算しましょう。

```tut:book
1 + ("Moonage daydream".indexOf("N"))
```

正解です!

ここまでを見て、いくつか気づいたことがあると思います:

 - コンピューターのように厳密に置き換えを行うには多くのステップを伴います。
 - 暗算で行った評価でも正しい答えを得ることができたかもしれません。
 - 一見適当に右から左に行った評価でも正しい答を得ることができました。

たまたま Scala が行っている置き換え順を選ぶことができたのか (違いますが、まだこれは調査していません)、どの順で評価しても関係無いのでしょうか?
最初の足し算の例のように、正しい答えの得られる近道があるのはどの場合でしょうか?
これらの質問を後ほど考察しますが、まずは名前がある場合に置き換えがどうなるかを見ていきましょう。

### 名前

名前の置き換えルールは、名前が参照する値で置き換えることです。
このルールは既にそれとなく使ってきたものですが、ここで形式化します。

具体例で解説すると、

```tut:silent:book
val name = "Ada"
name ++ " " ++ "Lovelace"
```

このコードに置き換えを適用して

```tut:silent:book
"Ada" ++ " " ++ "Lovelace"
```

を得ることができ、これは

```tut:silent:book
"Ada Lovelace"
```

に評価されます。

これで置き換えプロセスの中で名前をより形式的に取り扱うことができるようになりました。
例えば、最初に例に戻ると

```tut:silent:book
1 + 1
```

この式に名前を与えることができます:

```tut:silent:book
val two = 1 + 1
```

以下のような複合式があるとき

```tut:silent:book
(1 + 1) + (1 + 1)
```

置き換えによって `1 + 1` を `two` で置き換えて以下を得ることができます:

```tut:silent:book
two + two
```

この式を計算したとき

```tut:silent:book
1 + ("Moonage daydream".indexOf("N"))
```

私たちはサブ式に分解してから、それぞれを評価して置き換えました。
言葉を使ったため、これはかなり難解なものになってしまいました。
`val` 宣言を使うことで、これはよりコンパクトかる分かりやすく書き直すことができます。
以下は同じ式を部品に分解したものです。

```tut:silent:book
val a = 1
val b = "Moonage daydream"
val c = "N"
val d = b.indexOf(c)
val e = a + d
```

ここで (現在では適当に) 上から下の順に評価が行われると定義した場合、異なる評価順を試して結果に影響が出るか実験することができます。

例えば、

```tut:silent:book
val c = "N"
val b = "Moonage daydream"
val a = 1
val d = b.indexOf(c)
val e = a + d
```

は以前と同じ結果となります。
しかし、

```scala
val e = a + d
val a = 1
val b = "Moonage daydream"
val c = "N"
val d = b.indexOf(c)
```

は `e` が `a` と `d` に依存して、上から下の順序では `a` と `d` が評価されていないためうまくいきません。
これは試すのも少し馬鹿げていると思うかもしれません。最終的に評価しようとしている式は `e` であり、`a` と `d` は `e` のサブ式であるため、当然サブ式は式の前に評価される必要があります。
