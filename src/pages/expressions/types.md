## 型

より複雑な式が書けるようになった所で、型に関してもう少し話すことができます。

型の用例の 1つとして存在しないメソッドの呼び出しを防止するというものがあります。コンパイラが式を値に評価するとき、式の型はどのメソッドが存在するのかをコンパイラに教えてくれます。存在しないメソッドを呼び出そうとしてもそれはコンパイルされません。以下に簡単な具体例を使って説明します。

```tut:fail:book
"Brontë" / "Austen"
1.take(2)
```

本当に、式の型がどのメソッドを呼び出せるのかを決定します。これはより複雑な式に対してメソッドを呼び出すことで実験することができます。

```tut:fail:book
(1 + 3).take(1)
```

この**型検査**の処理は、メソッドのパラメータにも適用されます。

```tut:fail:book
1.min("zero")
```

型は式の属性で (以前にも話した通り) コンパイル時に存在します。そのため、実行時に式を評価した結果がエラーとなっても、式の型は決定することができます。例えば、`Int` をゼロで割ると実行時エラーが発生します。

```tut:fail:book
1 / 0
```

式 `1 / 0` はそれでも型を持ち、以下のようにして console で表示させることができます。

```scala
:type 1 / 0
// Int
```

実行時に失敗するサブ式を含んだ複合式を書くこともできます。

```tut:fail:book
(2 + (1 / 0) + 3)
```

そして、この式も型を持ちます。

```scala
:type (2 + (1 / 0) + 3)
// Int
```
